# Dynamic styling

While panda is mainly focused on the static styling experience, we have some mechanics to support dynamic styling.
"Dynamic" can have different meaning. Let's go over some of the ways you can do this.

## Sections

- [Conditional CSS](#conditional-css)
- [Arbitrary values](#arbitrary-values)
- [Arbitrary selectors](#arbitrary-selectors)
- [Runtime values](#runtime-values)
- [Runtime conditions](#runtime-conditions)
- [Referenced values](#referenced-values)

## Conditional CSS

Dynamic could mean that you want to change the styles based on some @media query, pseudo selectors or based on specific
selectors such as targeting data-\* attributes. Panda solves this using [conditions](/concepts/conditional-styles).

Let's say you want to change the color of a button when it is hovered. We can use the `_hover` condition that is
included in the default preset (`@pandacss/dev/presets`)

```tsx
import { css } from './styled-system/css'

const Button = () => {
  return (
    <button
      className={css({
        color: 'blue.100',
        // change the color on hover
        _hover: {
          color: 'red.300',
        },
      })}
    >
      Red on hover
    </button>
  )
}
```

If you have a commun use-case or want type-safety and auto-completion for your conditions, you should add it to the
config's conditions. Otherwise you can [Arbitrary selectors](#arbitrary-selectors)

## Arbitrary values

You can also use panda functions (`css`, `cva`, any [recipe](/recipe/config-recipe) or [pattern](/pattern/00-intro)) to
generate [atomic classes](/concepts/atomic-styles) for arbitrary values. Most of the time, you will want to use your
theme's known tokens values, but sometimes you might need a one-off value, for example to get a pixel-perfect
implementation of a design.

Panda functions can behave like a better `style` attribute that has access to any shorthands/conditions from your
config.

```tsx
import { css } from './styled-system/css'

const App = () => {
  return <div className={css({ left: '123px', _hover: { bgColor: '#2ecc71' } })} />
}
```

## Arbitrary selectors

What if you want need a one-off selector that is not defined in your config's [conditions](/concepts/conditional-styles)
? You can use the `css` function to generate classes for arbitrary selectors and
[nested styles](/concepts/nested-styles).

```tsx
import { css } from './styled-system/css'

const App = () => {
  return (
    <div
      className={css({
        '&[data-state=closed]': { color: 'red.300' },
        '& > *': { margin: '2' },
      })}
    />
  )
}
```

This will generate the following CSS:

```css
@layer utilities {
  .\[\&\[data-state\=closed\]\]\:text_red\.300[data-state='closed'] {
    color: var(--colors-red-300);
  }

  .\[\&_\>_\*\]\:m_2 > * {
    margin: var(--spacing-2);
  }
}
```

## Runtime values

You can also use runtime values, but you should be careful about it. Using a runtime value means using a value that is
not statically analyzable at build-time, and therefore you will lose the ability to automatically extract its styles to
a CSS file.

```tsx
import { css } from './styled-system/css'

const App = () => {
  const [color, setColor] = useState('red.300')

  return <div className={css({ color })} />
}
```

You can still have the corresponding CSS be generated by using the [`staticCss`](/static) option from the config. To fix
the example above, you could do this:

```tsx
import { defineConfig } from '@pandacss/dev'

export default defineConfig({
  staticCss: {
    css: [{ properties: { color: ['red.200'] } }],
  },
})
```

Another way to solve this is by using the `token()` CSS custom properties: That way panda knows the relationship between
the property and the variable while still being able to change the value at runtime.

```tsx
// Component.tsx
const Component = (props) => {
  return (
    <panda.div style={{ ['--dynamic-color']: token('colors.' + props.color) }} color="var(--dynamic-color)">
      Dynamic color with runtime value
    </panda.div>
  )
}

// App.tsx
const App = () => {
  const [runtimeColor, setRuntimeColor] = useState('pink.300')
  return <Component color={runtimeColor} />
}
```

> Note that if you know that the value won't be a runtime value, you could just have done this and it would just work:
>
> ```tsx
> // Component.tsx
> const Component = (props) => {
>   return <panda.div color={props.color}>Dynamic color with runtime value</panda.div>
> }
>
> // App.tsx
> const App = () => {
>   // this will be statically extractable and will automatically generate the corresponding CSS
>   return <Component color="blue.300" />
> }
> ```

## Runtime conditions

When encountering a runtime condition, panda will first try to resolve it statically. If it can't, it will fallback to
the generating the corresponding CSS for each possible branches.

```tsx
import { css } from './styled-system/css'
import { Stack } from './styled-system/jsx'

const App = () => {
  const [isHovered, setIsHovered] = useState(false)

  return (
    <Stack
      color={isHovered ? { _hover: 'red.100' } : 'red.200'}
      _hover={{ color: { base: 'red.300', md: isHovered ? 'red.400' : undefined } }}
    >
      <div className={css({ color: isHovered ? 'red.500' : 'red.600' })} />
    </Stack>
  )
}
```

Since none of the conditions above are statically extractable, it will generate css for all of those values into
something that looks like this:

```css
/* ... */
@layer utilities {
  .hover\:text_red\.100:where(:hover, [data-hover]) {
    color: var(--colors-red-100);
  }

  .text_red\.200 {
    color: var(--colors-red-200);
  }

  .hover\:text_red\.300:where(:hover, [data-hover]) {
    color: var(--colors-red-300);
  }

  @media screen and (min-width: 768px) {
    .hover\:md\:text_red\.400:where(:hover, [data-hover]) {
      color: var(--colors-red-400);
    }
  }

  .text_red\.500 {
    color: var(--colors-red-500);
  }

  .text_red\.600 {
    color: var(--colors-red-600);
  }
}
/* ... */
```

## Referenced values

Although you should have your styles inlined most of the time, maybe you want to store a value in a variable and re-use
in multiple places. This should be fine as long as you keep it statically analyzable.

Here's a short list of things to avoid:

- avoid using variables that are not defined in the same file
- avoid using variables resulting from a function call (e.g. `const color = getColor()`)

```tsx
import { css } from './styled-system/css'

const mainColor = 'red.300'
const sizes = { sm: '12px', md: '16px', '2xl': '42px' }

const App = () => {
  return <div className={css({ color: mainColor, fontSize: sizes.md, width: sizes['2xl'] })} />
}
```

## Summary

✅ What you can do :

```tsx

// conditional styles
<panda.div color={{ base: "red.100", md: "red.200" }} />

// arbitrary value
<panda.div color="#121qsd" />

// arbitrary selector
<panda.div css={{ ["&[data-thing] > span": { color: "red.100" } }} />

// runtime value (with config.`staticCss`)
const Button = () => {
  const [color, setColor] = useState('red.300')
  return <panda.button color={color} />
}

// runtime condition
<panda.div color={{ base: "red.100", md: isHovered ? "red.200" : "red.300" }} />

// referenced value
<panda.div color={mainColor} />

```

❌ What you can't do :

```tsx

// runtime value (without config.`staticCss`)
const Button = () => {
  const [color, setColor] = useState('red.300')
  return <panda.button color={color} />
}

// referenced value (not statically analyzable or from another file)
<panda.div color={getColor()} />
<panda.div color={colors[getColorName()]} />
<panda.div color={colors[colorFromAnotherFile]} />

```
