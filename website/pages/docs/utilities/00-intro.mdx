---
title: Utility-First CSS-in-JS
description: Panda is a powerful styling library that provides developers with primitives to create, organize, and manage CSS styles in a type-safe and readable manner.
---

# Utility-First CSS-in-JS

Panda is a powerful styling library that provides developers with primitives to create, organize, and manage CSS styles
in a type-safe and readable manner.

One of the key features of Panda is its built-in utilities or style properties, which provide a collection of
pre-defined custom css properties and shorthands to allow you create consistent and reusable UI components with speed.

Every style object is converted to atomic styles and is automatically scoped to the `@layer utilities` cascade layer to
allow for easy override experience with vanilla CSS or other styling libraries.

## Writing Styles

Let's say you need to create profile card component.

Using the traditional CSS approach, you'd have to define a class for each element:

```html
<div class="profile-card">
  <div class="profile-card__avatar">
    <img src="https://via.placeholder.com/150" alt="avatar" />
  </div>
  <div class="profile-card__name">John Doe</div>
  <div class="profile-card__email">john@doe.com</div>
</div>

<style>
  .profile-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    border-radius: 0.5rem;
    background-color: #fff;
    box-shadow: 0 0 0.5rem rgba(0, 0, 0, 0.1);
  }

  .profile-card__avatar {
    width: 5rem;
    height: 5rem;
    border-radius: 50%;
    overflow: hidden;
  }

  .profile-card__avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .profile-card__name {
    margin-top: 1rem;
    font-size: 1.25rem;
    font-weight: 600;
  }

  .profile-card__email {
    margin-top: 0.5rem;
    font-size: 0.875rem;
    color: #666;
  }
</style>
```

This approach works for simple components, but it quickly becomes tedious and hard to maintain as the component grows.
The css size also grows exponentially as the number of components increases.

Another popular approach is to use utility classes, which are pre-defined classes that provide a set of style properties
to allow you to quickly create UI components.

```html
<div
  class="flex flex-col items-center justify-center p-4 rounded bg-white shadow-lg"
>
  <div class="w-20 h-20 rounded-full overflow-hidden">
    <img src="https://via.placeholder.com/150" alt="avatar" />
  </div>
  <div class="mt-4 text-xl font-semibold">John Doe</div>
  <div class="mt-2 text-sm text-gray-600">john@doe.com</div>
</div>
```

This approach is much more readable and maintainable, but it comes with a few drawbacks:

- Lack of type safety due to the string based API.
- The length of the className increases exponentially a component grows in complexity making it harder to read and
  maintain.

With Panda, you can achieve the same component with type-safe, style objects that resolve to the same CSS as the utility
classes without the runtime CSS-in-JS overhead.

```jsx
import { css } from './panda/css'
import { circle, stack } from './panda/patterns'

function App() {
  return (
    <div
      className={stack({
        direction: 'row',
        p: '4',
        rounded: 'md',
        shadow: 'lg',
        bg: 'white'
      })}
    >
      <div className={circle({ size: '5rem', overflow: 'hidden' })}>
        <img src="https://via.placeholder.com/150" alt="avatar" />
      </div>
      <div className={css({ mt: '4', fontSize: 'xl', fontWeight: 'semibold' })}>
        John Doe
      </div>
      <div className={css({ mt: '2', fontSize: 'sm', color: 'gray.600' })}>
        john@doe.com
      </div>
    </div>
  )
}
```

or if you're a JSX style props fanatic, Panda has you covered:

```jsx
import { Box, Stack, Circle } from './panda/jsx'

function App() {
  return (
    <Stack direction="row" p="4" rounded="md" shadow="lg" bg="white">
      <Circle size="5rem" overflow="hidden">
        <img src="https://via.placeholder.com/150" alt="avatar" />
      </Circle>
      <Box mt="4" fontSize="xl" fontWeight="semibold">
        John Doe
      </Box>
      <Box mt="2" fontSize="sm" color="gray.600">
        john@doe.com
      </Box>
    </Stack>
  )
}
```

The resulting HTML and CSS will look like this:

```html
<div class="d_flex flex_row items_center p_4 rounded_md bg-white shadow-lg">
  <div class="w_20 h_20 rounded_full overflow_hidden">
    <img src="https://via.placeholder.com/150" alt="avatar" />
  </div>
  <div class="mt_4 fs_xl font-semibold">John Doe</div>
  <div class="mt_2 fs_sm color_gray.600">john@doe.com</div>
</div>

<style>
  @layer utilities {
    .d_flex {
      display: flex;
    }
    .flex_row {
      flex-direction: row;
    }
    .items_center {
      align-items: center;
    }
    .p_4 {
      padding: 1rem;
    }

    /* ... */

    .mt_2 {
      margin-top: var(--space-2);
    }
    .fs_sm {
      font-size: var(--fontSizes-sm);
    }
    .color_gray.600 {
      color: var(--color-gray-600);
    }
  }
</style>
```

This approach allows you to create UI components with speed and consistency, while also outputting atomic styles at
build time, all wrapped in a type-safe and intuitive development experience. You never have to write a single line of
custom CSS. Isn't that amazing?!

In the example above, we've used:

- Panda's `stack` and `circle` function which are [built-in patterns](#) that provides style presets to prevent you from
  repeating the same style properties over and over again.
- Panda's `css` function which is the tiny runtime that converts style objects to atomic classes (without any runtime
  overhead).
- Style shorthands like `mt`, `bg`, and `p` which are shorthands for `margin-top`, `background-color`, and `padding`
  style properties respectively.

## Type safety

Panda is built with TypeScript and provides type safety for all style properties and shorthands. Most of the style
properties are connect to either the native CSS properties or their respective token value defined as defined in the
`theme` object.

```ts
//                            â¤µ you'll get autocomplete for colors
const buttonClass = css({ bg: '|' })
```

You can also set `strict: true` in the config to only allow token value and prevent custom or raw CSS values.

## Classname Hashing

In some cases, the long `className` can be a bit annoying to read and you might prefer to have shorter classnames. You
can use the `hash` option to enable classname hashing.

```ts
// config.ts

export const config = {
  hash: true
}
```

This will generate hashed classnames that look like:

```css
.dsf3wd {
  display: flex;
}

.kdi9jd {
  flex-direction: row;
}
```

> We recommend that you use this in production builds only as it can make debugging a bit harder.
