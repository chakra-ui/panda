---
title: Dynamic styling
description: While panda is mainly focused on the static styling experience, we have some mechanics to support dynamic styling.
---

# Dynamic styling

While panda is mainly focused on the static styling experience, we have some mechanics to support dynamic styling.

We recommend that you **avoid relying on runtime values most of the time** and instead use the alternatives we offer
(css vars, conditions, cva, etc..) since they allow for some level of dynamic styling while still retaining the benefits
of static CSS.

That being said, "Dynamic" can have different meaning. Let's go over some of the ways you can do this.

## Sections

- [Conditional CSS](#conditional-css)
- [Arbitrary values](#arbitrary-values)
- [Arbitrary selectors](#arbitrary-selectors)
- [Runtime values](#runtime-values)
- [Runtime conditions](#runtime-conditions)
- [Referenced values](#referenced-values)

## Conditional CSS

Dynamic could mean that you want to change the styles based on some @media query, pseudo selectors or based on specific
selectors such as targeting data-\* attributes. Panda solves this using
[conditions](/docs/concepts/conditional-styles.mdx).

Let's say you want to change the color of a button when it is hovered. We can use the `_hover` condition that is
included in the default preset (`@pandacss/dev/presets`)

```tsx
import { css } from './styled-system/css'

const Button = () => {
  return (
    <button
      className={css({
        color: 'blue.100',
        // change the color on hover
        _hover: {
          color: 'red.300'
        }
      })}
    >
      Red on hover
    </button>
  )
}
```

If you have a commun use-case or want type-safety and auto-completion for your conditions, you should add it to the
config's conditions. Otherwise you can [Arbitrary selectors](#arbitrary-selectors)

## Arbitrary values

You can also use panda functions (`css`, `cva`, any [recipe](/docs/recipe/config-recipe.mdx) or
[pattern](/docs/patterns/00-intro.mdx)) to generate [atomic classes](/docs/concepts/atomic-styles.mdx) for arbitrary
values. Most of the time, you will want to use your theme's known tokens values, but sometimes you might need a one-off
value, for example to get a pixel-perfect implementation of a design.

Panda functions can behave like a better `style` attribute that has access to any shorthands/conditions from your
config.

```tsx
import { css } from './styled-system/css'

const App = () => {
  return (
    <div className={css({ left: '123px', _hover: { bgColor: '#2ecc71' } })} />
  )
}
```

## Arbitrary selectors

What if you want need a one-off selector that is not defined in your config's
[conditions](/docs/concepts/conditional-styles.mdx) ? You can use the `css` function to generate classes for arbitrary
selectors and [nested styles](/docs/concepts/nested-styles.mdx).

```tsx
import { css } from './styled-system/css'

const App = () => {
  return (
    <div
      className={css({
        '&[data-state=closed]': { color: 'red.300' },
        '& > *': { margin: '2' }
      })}
    />
  )
}
```

This will generate the following CSS:

```css
@layer utilities {
  .\[\&\[data-state\=closed\]\]\:text_red\.300[data-state='closed'] {
    color: var(--colors-red-300);
  }

  .\[\&_\>_\*\]\:m_2 > * {
    margin: var(--spacing-2);
  }
}
```

## Runtime values

You can also use runtime values, but you should be careful about it. Using a runtime value means using a value that is
not statically analyzable at build-time, and therefore you will lose the ability to automatically extract its styles to
a CSS file.

```tsx
import { css } from './styled-system/css'

const App = () => {
  const [color, setColor] = useState('red.300')

  return <div className={css({ color })} />
}
```

You can still have the corresponding CSS be generated by using the [`staticCss`](/docs/static.mdx) option from the
config. To fix the example above, you could do this:

```tsx
import { defineConfig } from '@pandacss/dev'

export default defineConfig({
  staticCss: {
    css: [{ properties: { color: ['red.200'] } }]
  }
})
```

Another way to solve this is by using the `token()` function in addition to CSS custom properties : That way panda knows
about the relationship between the property and the variable while still being able to change the value at runtime.

Using the `token()` function:

```tsx
// Component.tsx
import { token } from '../styled-system/tokens'

const Component = props => {
  return (
    <panda.div
      style={{ ['--dynamic-color']: token('colors.' + props.color) }}
      color="var(--dynamic-color)"
    >
      Dynamic color with runtime value
    </panda.div>
  )
}

// App.tsx
const App = () => {
  const [runtimeColor, setRuntimeColor] = useState('pink.300')
  return <Component color={runtimeColor} />
}
```

You could also directly use the `token.var()` function to get a reference to the panda CSS custom property for a given
token:

```tsx
// Component.tsx
import { token } from '../styled-system/tokens'

const Component = props => {
  return (
    <div style={{ color: token.var('colors.' + props.color) }}>
      Dynamic color with runtime value
    </div>
  )
}

// App.tsx
const App = () => {
  const [runtimeColor, setRuntimeColor] = useState('yellow.300')
  return <Component color={runtimeColor} />
}
```

> Note that if you know that the value won't be a runtime value (meaning you will statically use the value somewhere
> else) , you could just have done this and it would just work:
>
> ```tsx
> // Component.tsx
> const Component = props => {
>   return (
>     <panda.div color={props.color}>
>       Dynamic color with runtime value
>     </panda.div>
>   )
> }
>
> // App.tsx
> const App = () => {
>   // this will be statically extractable and will automatically generate the corresponding CSS
>   return <Component color="blue.300" />
> }
> ```

## Runtime conditions

Even though wee recommend that you first look for better alternatives (such as using
[recipe variants](/docs/recipe/config-recipe.mdx)), you may still occasionally need runtime conditions.

When encountering a runtime condition, panda will first try to resolve it statically. If it can't, it will fallback to
the generating the corresponding CSS for each possible branches.

```tsx
import { css } from './styled-system/css'
import { Stack } from './styled-system/jsx'

const App = () => {
  const [isHovered, setIsHovered] = useState(false)

  return (
    <Stack
      color={isHovered ? { _hover: 'red.100' } : 'red.200'}
      _hover={{
        color: { base: 'red.300', md: isHovered ? 'red.400' : undefined }
      }}
    >
      <div className={css({ color: isHovered ? 'red.500' : 'red.600' })} />
    </Stack>
  )
}
```

Since none of the conditions above are statically extractable, it will generate css for all of those values into
something that looks like this:

```css
/* ... */
@layer utilities {
  .hover\:text_red\.100:where(:hover, [data-hover]) {
    color: var(--colors-red-100);
  }

  .text_red\.200 {
    color: var(--colors-red-200);
  }

  .hover\:text_red\.300:where(:hover, [data-hover]) {
    color: var(--colors-red-300);
  }

  @media screen and (min-width: 768px) {
    .hover\:md\:text_red\.400:where(:hover, [data-hover]) {
      color: var(--colors-red-400);
    }
  }

  .text_red\.500 {
    color: var(--colors-red-500);
  }

  .text_red\.600 {
    color: var(--colors-red-600);
  }
}
/* ... */
```

## Referenced values

Although you should have your styles inlined most of the time, maybe you want to store a value in a variable and re-use
in multiple places. This should be fine as long as you keep it statically analyzable.

Here's a short list of things to avoid:

- avoid using variables that are not defined in the same file
- avoid using variables resulting from a function call (e.g. `const color = getColor()`)

```tsx
import { css } from './styled-system/css'

const mainColor = 'red.300'
const sizes = { sm: '12px', md: '16px', '2xl': '42px' }

const App = () => {
  return (
    <div
      className={css({
        color: mainColor,
        fontSize: sizes.md,
        width: sizes['2xl']
      })}
    />
  )
}
```

### Runtime reference on known objects

Using a more complex but still common example :

```tsx
const colorByType = {
  primary: 'red.300',
  secondary: 'blue.300',
  tertiary: 'green.300'
}

const Section = () => {
  const [type, setType] = useState('primary')

  // since only "gray.100" is statically extractable here
  // ❌ this will not work as expected, the color CSS won't be generated
  return (
    <section className={css({ color: colorByType[type] ?? 'gray.100' })}>
      ❌ Will not be extracted
    </section>
  )
}
```

Even though `colorByType` is statically analyzable, panda does not _yet_ support this kind of automatic extraction
fallback.

But this looks like the perfect opportunity to use the [`cva`](/docs/recipe/atomic-recipe.mdx) function !

```tsx
import { cva } from './styled-system/cva'

const sectionRecipe = cva({
  base: { color: 'gray.100' },
  variants: {
    type: {
      primary: { color: 'red.300' },
      secondary: { color: 'blue.300' },
      tertiary: { color: 'green.300' }
    }
  }
})

const Section = () => {
  const [type, setType] = useState('primary')

  // since the whole `cva` config will be extracted & corresponding CSS be generated
  // ✅ this will work as expected
  return <section className={sectionRecipe({ type })}>✅ With a recipe</section>
}
```

Not only did you get the same end result, but you also got a more readable and maintainable code !

You can now :

- add more variants to your recipe
- add more properties
- use a shorthand or a condition

All of this with complete type-safety and without having to make drastic changes to the component.

> Note that you can also [integrate this recipe directly into your theme](/docs/recipe/config-recipe.mdx) if you want to
> only generate the CSS that you use, among other things

## Summary

✅ What you can do :

```tsx

// conditional styles
<panda.div color={{ base: "red.100", md: "red.200" }} />

// arbitrary value
<panda.div color="#121qsd" />

// arbitrary selector
<panda.div css={{ ["&[data-thing] > span": { color: "red.100" } }} />

// runtime value (with config.`staticCss`)
const Button = () => {
  const [color, setColor] = useState('red.300')
  return <panda.button color={color} />
}

// runtime condition
<panda.div color={{ base: "red.100", md: isHovered ? "red.200" : "red.300" }} />

// referenced value
<panda.div color={mainColor} />

```

❌ What you can't do :

```tsx

// runtime value (without config.`staticCss`)
const Button = () => {
  const [color, setColor] = useState('red.300')
  return <panda.button color={color} />
}

// referenced value (not statically analyzable or from another file)
<panda.div color={getColor()} />
<panda.div color={colors[getColorName()]} />
<panda.div color={colors[colorFromAnotherFile]} />

```
